📒 **오답노트 – BOJ 1074 Z**

---

### 1. 문제 요약

* 크기가 $2^N \times 2^N$인 배열을 Z 모양 순서로 방문할 때,
  특정 좌표 `(r, c)`가 몇 번째로 방문되는지 구하는 문제.
* N ≤ 15, r, c < $2^N$

---

### 2. 내가 시도한 방식

* **분할정복(Divide & Conquer)** 아이디어로 접근.
* 전체 배열을 4등분하여 `QuadTree` 재귀로 순서대로 채우고,
  마지막에 `graph[r][c]`를 출력.
* 기저 조건은 n=2일 때, 4칸의 순서를 직접 채움.

```python
graph = [[0]*(2**N) for _ in range(2**N)]
i = 0

def QuadTree(n, x, y):
    if n != 2:
        half = n//2
        QuadTree(half, x, y)             # 왼쪽 위
        QuadTree(half, x+half, y)        # 오른쪽 위
        QuadTree(half, x, y+half)        # 왼쪽 아래
        QuadTree(half, x+half, y+half)   # 오른쪽 아래
    if n == 2:
        graph[y][x] = i
        graph[y][x+1] = i+1
        graph[y+1][x] = i+2
        graph[y+1][x+1] = i+3
```

---

### 3. 시도의 장점

* 문제 설명 그대로 구현해서 이해하기 쉬움.
* 작은 N(N ≤ 3\~5 정도)에서는 잘 동작함.
* 전형적인 **분할정복 구조**로, 큰 문제를 작은 문제 4개로 나누는 접근이 올바름.

---

### 4. 시도의 한계

1. **메모리 초과**

   * N=15일 때 배열 크기: $32768 \times 32768$ = 약 10억 칸
   * int 값 저장 시 최소 4GB 이상 필요 → 제한(512MB) 초과

2. **시간 초과**

   * 모든 칸에 값을 채우려면 O($4^N$) 연산
   * N=15면 약 $4^{15} \approx 10^9$번 연산 → 0.5초 내 불가능

3. **전역 변수 i 미갱신**

   * 재귀 안에서 `i`가 증가하지 않아 모든 칸이 같은 값이 됨.

4. **기저 조건 고정**

   * `n==2`일 때만 채우는 구조라 N=1 같은 경우 처리 흐름이 부자연스러움.

---

### 5. 개선 아이디어

* 배열 전체를 채우지 말고, `(r, c)` 좌표만 추적.
* 각 재귀 단계에서 `(r, c)`가 어느 사분면에 속하는지 확인하고,
  그 이전 사분면의 칸 수만큼 offset을 더해 나가면 됨.
* 메모리 O(1), 시간 O(N)로 가능.

---

### 6. 결론

* **내 시도**: 완전 시뮬레이션 기반 분할정복 → 개념은 맞지만 비효율적.
* **문제 해결법**: 좌표 추적 기반 분할정복 → 실전 제한 통과 가능.
* 교훈: 분할정복이라도 “필요한 부분만” 처리하도록 최적화해야 함.


