

# 1987번 알파벳 다국어 – 오답 & 학습 노트

### 1️⃣ 문제 요약

* 세로 `R`, 가로 `C` 보드에 알파벳이 하나씩 있음.
* 말은 상하좌우 이동 가능, **이미 지나온 알파벳은 다시 밟을 수 없음**.
* 목표: 좌측 상단에서 시작해 **최대 몇 칸을 지날 수 있는지** 구하기.
* 제한: `1 ≤ R, C ≤ 20` → 최대 400칸, 알파벳 26개.

---

### 2️⃣ 처음 시도한 코드

```python
alpha = [False] * 26

def dfs(y, x, cnt):
    global answer
    answer = max(answer, cnt)
    
    for i in range(4):
        ny, nx = y + dy[i], x + dx[i]
        if 0 <= ny < r and 0 <= nx < c:
            idx = ord(grid[ny][nx]) - ord('A')
            if not alpha[idx]:
                alpha[idx] = True
                dfs(ny, nx, cnt + 1)
                alpha[idx] = False
```

✅ 장점:

* 단순하고 직관적임.
* 알파벳 중복 체크(`alpha[]`)로 문제 조건 만족.

❌ 문제점:

* **시간 초과** 발생.
* 이유: **같은 알파벳 집합 상태로 여러 좌표에 도달할 수 있음 → 중복 탐색 폭발**.

---

### 3️⃣ 시간초과 원인

1. DFS에서 `alpha[]`만 체크 → 좌표별 경로는 다르지만 같은 알파벳 집합으로 여러 번 탐색됨.
2. 예시:

```
A B
C D
```

* 경로 1: `(0,0)->(0,1)->(1,1)->(1,0)`
* 경로 2: `(0,0)->(1,0)->(1,1)->(0,1)`
* 같은 좌표 `(1,1)`지만 알파벳 순서가 달라 DFS가 다시 끝까지 탐색 → 중복 발생.

---

### 4️⃣ 해결 아이디어

**중복 상태 제거**

* 상태 정의: `(y좌표, x좌표, 지금까지 사용한 알파벳 집합)`
* 같은 상태로 이미 방문했다면 **더 탐색하지 않음**.
* 구현 방법 2가지:

#### 방법 1: 비트마스크

```python
mask = 1 << (ord(grid[y][x]) - ord('A'))
dfs(ny, nx, mask | next_idx, cnt + 1)
```

* `mask` 하나로 알파벳 집합 표현 → 빠르고 메모리 효율적.
* 상태 방문 체크: `visited = set()`에 `(y, x, mask)` 저장.

#### 방법 2: alpha\[] + tuple

```python
state = (y, x, tuple(alpha))
if state in visited:
    return
visited.add(state)
```

* `alpha[]` 배열을 튜플로 변환하여 상태 기록.
* 비트마스크보다 느리지만 구현 직관적.

---

### 5️⃣ 중요한 포인트

1. “앞부분 루트가 같아도 뒤가 달라질 수 있으니 단순 리턴은 위험” → **오해**

   * 사실 중요한 건 **좌표+알파벳 집합**
   * 같은 상태면 이후 갈 수 있는 후보 칸이 완전히 동일 → 재탐색 필요 없음
2. 좌표만 체크하거나 alpha\[]만 체크하면 중복 발생 → 시간 초과
3. 비트마스크 사용하면 연산과 상태 저장 최적화 가능

---

### 6️⃣ 핵심 요약

* DFS/백트래킹 시 **상태 중복 제거 필수**.
* 상태 = `(좌표, 지금까지 밟은 알파벳 집합)`.
* 구현 방식:

  1. 비트마스크 → 빠르고 권장
  2. alpha\[] + tuple → 직관적, 공부용
* 단순 alpha\[]만으로 DFS 돌리면 경로 중복 탐색 → 시간 초과

---

이 내용을 정리하면, 다음번 비슷한 문제에서

* 단순한 DFS로는 시간초과 날 수 있음
* 상태 정의와 중복 제거를 항상 고려해야 함


혹시 만들어드릴까요?
