

## 📝 오답노트 — 백준 1193 `분수찾기`

### 1. 내가 놓친 점

* **대각선 단위로 규칙이 있다는 것**을 못 떠올림.
* `X`번째 분수가 **몇 번째 대각선에 있는지** 먼저 찾는 아이디어가 없었음.
* 1 + 2 + 3 + ... + n 형태의 **삼각수 공식** `(n*(n+1))/2`를 몰라서, 누적합 계산을 떠올리지 못함.

---

### 2. 문제의 핵심 아이디어

1. 분수는 **대각선별로 묶어서** 지그재그로 나열됨.
2. 대각선 번호 `n`까지의 원소 개수 합 = `n*(n+1)//2`
3. `X`번째가 속한 대각선을 찾으면, 그 안에서의 \*\*위치(pos)\*\*만 계산하면 됨.
4. 대각선의 방향(홀수 ↔ 짝수)에 따라 분자/분모 증가·감소 순서가 달라짐.

---

### 3. 규칙 정리

대각선 예시:

```
1: (1/1)           → 1개
2: (1/2, 2/1)      → 2개
3: (3/1, 2/2, 1/3) → 3개
4: (1/4, 2/3, 3/2, 4/1) → 4개
...
```

* **대각선 개수** = 대각선 번호와 동일
* **총 개수** = `1 + 2 + ... + n = n*(n+1)/2`

---

### 4. 풀이 절차

1. **대각선 찾기**

   * `while n*(n+1)//2 < X` → n 증가
2. **대각선 내 위치 계산**

   * `prev_sum = (n-1)*n//2`
   * `pos = X - prev_sum`
3. **방향 결정**

   * 홀수 대각선 → 위에서 아래
   * 짝수 대각선 → 아래에서 위
4. **분자/분모 구하기**

   * 짝수: `(pos, n-pos+1)`
   * 홀수: `(n-pos+1, pos)`

---

### 5. 깨달은 점

* 단순 반복보다 **규칙을 찾아 수학식으로 계산**하면 훨씬 빠르고 깔끔해짐.
* 1+2+3+...+n = **삼각수 공식**은 자주 쓰이는 기본 공식 → 기억해두기.
* 이런 문제는 **2차원 좌표 ↔ 1차원 인덱스 변환** 관점에서 접근하면 규칙을 찾기 쉬움.

---

### 6. 다시 풀었을 때의 코드

```python
X = int(input())

n = 1
while n*(n+1)//2 < X:
    n += 1

prev_sum = (n-1)*n//2
pos = X - prev_sum

if n % 2 == 0:
    print(f"{pos}/{n-pos+1}")
else:
    print(f"{n-pos+1}/{pos}")
```
