
## 📚 오답노트: 백준 18870번 – 좌표 압축

### 🔸 문제 개요

* 수직선 위의 N개 좌표 `X₁, X₂, ..., Xₙ`에 대해, **자기보다 작은 값의 개수**를 압축된 좌표로 만든다.
* 예: `[2, 4, -10, 4, -9]` → `[2, 3, 0, 3, 1]`

---

### ❌ 내가 처음 생각한 접근 (오답)

> 각 좌표마다 직접 순회해서 자신보다 작은 값이 몇 개인지 세려고 함.

#### 문제점

* **시간복잡도 O(N²)**
  → N이 최대 1,000,000이므로 시간 초과 발생
* **비효율적**이며, 큰 입력에서는 실행조차 되지 않음

---

### ✅ 정답 아이디어: 정렬 + 매핑

> “값을 정렬한 후 인덱스를 매핑하면, 자동으로 ‘자기보다 작은 값의 개수’를 구할 수 있다.”

#### 핵심 흐름

1. **중복 제거 + 정렬**
   → 정렬된 순서가 곧 "자기보다 작은 수의 개수"다.

   ```python
   sorted_unique = sorted(set(nums))
   ```

2. **값 → 인덱스 매핑**

   ```python
   num_dict = {num: i for i, num in enumerate(sorted_unique)}
   ```

3. **원래 입력값에 대해 매핑 적용**

   ```python
   print(' '.join(str(num_dict[num]) for num in nums))
   ```

---

### 🔍 왜 이게 "작은 값의 개수"가 되지?

정렬된 리스트에서 어떤 수의 인덱스는,
그 수보다 작은 수들의 개수와 **동일하다**.

예:
정렬된 리스트 `[-10, -9, 2, 4]`
→ -10의 인덱스는 0 → 앞에 아무것도 없음
→ 2의 인덱스는 2 → 앞에 2개 있음 (-10, -9)

---

### ✅ 배운 점 요약

| 항목          | 내용                                        |
| ----------- | ----------------------------------------- |
| **실패 원인**   | 직접 비교 방식으로 접근하여 시간초과 발생                   |
| **핵심 아이디어** | 정렬된 리스트에서 인덱스를 사용하면 "작은 수 개수"를 빠르게 알 수 있음 |
| **기술 포인트**  | `set()`으로 중복 제거 후 `sorted()` → `dict`로 매핑 |
| **시간복잡도**   | O(N log N)으로 해결 가능                        |

---

### 🧠 기억할 것

* **좌표 압축**이 나올 때는 항상 **정렬 후 인덱스 매핑**을 생각할 것
* 반복문으로 직접 세는 건 절대 안 됨 (N이 클 경우)
* "압축"이란 결국 "**상대적 순위**를 매기는 것"이라는 감각을 익히자


