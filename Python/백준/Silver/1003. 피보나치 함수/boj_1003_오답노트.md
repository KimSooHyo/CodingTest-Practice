## ✅ 1. 정답 코드 (DP 방식)

### 핵심 아이디어

* 피보나치 수의 **값을 구하는 게 아니라**, `fibonacci(n)`을 호출할 때 `fibonacci(0)`과 `fibonacci(1)`이 **각각 몇 번 호출되는지를 미리 구해놓자**.
* **중복 호출을 피하고**, 이미 계산된 결과를 재사용하는 **동적 프로그래밍(DP)** 방식 사용.

```python
import sys
input = sys.stdin.readline

# [0 출력 횟수, 1 출력 횟수]
dp = [[0, 0] for _ in range(41)]
dp[0] = [1, 0]
dp[1] = [0, 1]

for i in range(2, 41):
    dp[i][0] = dp[i-1][0] + dp[i-2][0]
    dp[i][1] = dp[i-1][1] + dp[i-2][1]

T = int(input())
for _ in range(T):
    n = int(input())
    print(dp[n][0], dp[n][1])
```

---

## 🧠 2. 재귀 방식의 문제점

### 네가 처음 작성한 코드 요약:

```python
def fibonacci(n):
    count0 = 0
    count1 = 0
    if n == 0:
        count0 += 1
    elif n == 1:
        count1 += 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)
    return count0, count1
```

### ❌ 문제점:

* `fibonacci(n-1) + fibonacci(n-2)`를 호출했을 때, **각각의 출력 횟수를 누적하지 않음**.
* 반환된 `count0, count1` 값을 **더하지 않고 단순히 함수 호출만 하고 있음**.
* 즉, **출력 횟수를 세는 로직이 완전히 누락됨**.

---

## 📉 3. 재귀 방식의 시간 복잡도

### 재귀 피보나치의 시간 복잡도는?

* `fibonacci(n) = fibonacci(n-1) + fibonacci(n-2)`
* 이 구조는 **매 호출마다 두 번씩 함수가 더 호출되므로**, **O(2^n)** 의 지수 시간 복잡도.

예를 들어:

* `fibonacci(30)` → 약 2^30 ≈ 10억 번 호출
* `fibonacci(40)` → 약 10조 번 호출

### ❗ 문제 조건:

> N은 0 ≤ N ≤ 40
> 시간 제한: **0.25초**

➡️ **O(2^40)** 은 절대 통과 못함. 재귀 방식은 시간 초과(TLE: Time Limit Exceeded)가 납니다.

---

## ✅ 4. DP 방식의 시간 복잡도

* `for i in range(2, 41)` → 반복 39번
* `T`개의 테스트 케이스 처리도 O(1)씩

➡️ 전체 시간 복잡도: **O(N + T)**
➡️ **빠르고 효율적이며 문제 조건을 완벽히 만족**

---

## 🔍 5. 네가 실수한 핵심 포인트 요약

| 실수                     | 설명                                                                        |
| ---------------------- | ------------------------------------------------------------------------- |
| ✅ 재귀 결과를 누적 안 함        | `fibonacci(n-1) + fibonacci(n-2)`의 결과를 합쳐야 하는데 `count0`, `count1`에 더하지 않음 |
| ✅ 출력 횟수가 아닌 함수 반환값만 사용 | 문제는 반환값이 아니라 `0`과 `1`이 각각 **몇 번 출력**되는지를 세는 게 목적                          |
| ❌ 시간 복잡도 고려 부족         | 재귀는 O(2^n)이라 N=40이면 절대 시간 내에 끝나지 않음                                       |
| ✅ DP 사용 필요성 인식 못함      | 출력 횟수도 피보나치 수열처럼 재사용 가능 → 미리 구해두는 것이 핵심                                   |

---

## 🧾 마무리 요약

| 항목        | 재귀 방식           | DP 방식           |
| --------- | --------------- | --------------- |
| 구조        | 함수 계속 호출        | 배열에 저장 후 반복문 사용 |
| 시간 복잡도    | O(2^n) (매우 느림)  | O(n) (매우 빠름)    |
| 문제 통과 가능? | ❌ 시간 초과         | ✅ 통과 가능         |
| 네 코드 문제점  | 누적 안 함, 반환값만 사용 | X               |

---

## 👉 다음 목표

* DP 개념 더 연습해보기 (특히 피보나치처럼 **중복 계산 줄이는 문제**)
* 재귀 함수 쓸 때 **결과 누적 방식**, 반환값 처리 주의하기
* `print()`와 리턴값을 구분해서 생각하기
