## 📒 오답노트

### 문제

* 길이 `k`의 연속 부분합 중 최댓값을 구하는 문제.
* **내 코드**

  * 매번 `sum(nums[i:i+k])`을 계산 → 슬라이싱 O(k) + 합 계산 O(k) → 전체 O(n\*k)
  * n, k가 커질 경우 시간 초과 위험.
  * k가 매번 달라지는 경우도 있어 추가 최적화 방안 고민이 필요.

---

### 실수한 점

1. **슬라이딩 윈도우 발상 자체를 못함**

   * 한 칸씩 이동할 때 **앞 원소 빼고, 새 원소 더하는 방식**을 생각하지 못함.
   * 이 방식이면 첫 합만 O(k)로 구하고 이후는 O(1) 연산 → 전체 O(n) 가능.

2. **누적합(prefix sum)의 활용을 시도하지 않음**

   * 누적합은 한 번만 O(n)으로 만들면,
     임의의 구간 합을 O(1)에 구할 수 있음.
   * k가 변하더라도 누적합은 그대로 재활용 가능.
   * 나는 k가 변하면 누적합을 못 쓴다고 생각해서 시도조차 안 함.

---

### 개선 아이디어

#### 1. **슬라이딩 윈도우** (k 고정 시 최적)

```python
window_sum = sum(nums[:k])
max_sum = window_sum

for i in range(k, n):
    window_sum += nums[i] - nums[i-k]
    max_sum = max(max_sum, window_sum)

print(max_sum)
```

* 첫 구간 합 구한 뒤, 이동 시 맨 앞 원소 빼고 새 원소 더함.
* 시간 복잡도: **O(n)**, 공간 복잡도: **O(1)**

#### 2. **누적합(prefix sum)** (k 변동 시 유용)

```python
prefix_sum = [0]
for num in nums:
    prefix_sum.append(prefix_sum[-1] + num)

max_sum = max(prefix_sum[i+k] - prefix_sum[i] for i in range(n-k+1))
print(max_sum)
```

* k가 바뀌어도 `prefix_sum` 그대로 사용 가능.
* 질의가 여러 개여도 누적합 계산은 한 번만 하면 됨.

---

### 배운 점

* **슬라이딩 윈도우**는 “연속 구간” 문제에서 시간 최적화의 핵심 패턴.
* **누적합**은 k가 변하거나 구간 합 질의가 여러 번 있을 때 강력함.
* “k가 변하면 누적합 불가능”이라는 내 고정관념이 틀렸음 → 한 번만 만들고 재활용 가능.

---

📌 **다음에 비슷한 문제 나오면**

1. k가 고정 → 슬라이딩 윈도우 고려.
2. k가 변하거나 여러 구간 질의 → 누적합 활용.
3. 불필요한 set, 리스트 슬라이싱 제거로 불필요한 O(k) 연산 없애기.

