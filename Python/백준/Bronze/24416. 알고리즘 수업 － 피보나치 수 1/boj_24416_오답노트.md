

## 📘 오답노트: 백준 24416 - 알고리즘 수업 - 피보나치 수 1

---

### ❓ **문제 요약**

* `fib(n)`을 **재귀로 구현**했을 때, `return 1`이 실행되는 횟수 (코드1)
* `fibonacci(n)`을 **반복문(DP)으로 구현**했을 때, `f[i] = f[i-1] + f[i-2]`가 실행되는 횟수 (코드2)
* 이 두 개의 실행 횟수를 출력하는 문제

---

### ❌ **내가 처음에 헷갈린 점**

1. **모든 함수 호출을 카운트해야 하는 줄 알았음**

   * `fib(n)`을 호출할 때마다 count를 늘려야 한다고 착각
   * 하지만 실제론 **`fib(1)` 또는 `fib(2)`일 때만 count**

2. **시간 초과를 피하려고 메모이제이션을 사용함**

   * `fib(n)`에서 중복 호출을 피하려고 `memo` 딕셔너리로 캐싱함
   * 근데 이건 문제의 **의도와 맞지 않음**

     * → 문제는 **비효율적인 재귀 호출**을 그대로 구현해서 `fib(1)`과 `fib(2)`가 **얼마나 많이 호출되는지** 확인하는 것

3. **출력값이 문제의 예시와 다르게 나옴**

   * 메모이제이션 덕분에 코드1 실행 횟수가 줄어들었고, 정답과 다름

---

### ✅ **정확한 문제 의도 정리**

| 항목     | 설명                                                  |
| ------ | --------------------------------------------------- |
| 코드1 횟수 | `fib(n)`을 재귀 호출했을 때, `fib(1)` 또는 `fib(2)`가 호출된 총 횟수 |
| 코드2 횟수 | DP 방식에서 `f[i] = f[i-1] + f[i-2]`가 실행된 횟수 = `n - 2`  |

---

### ✅ **문제의 의도대로 푸는 방법**

```python
def fib_count(n):
    fib = [0] * (n + 1)
    fib[1] = fib[2] = 1
    for i in range(3, n + 1):
        fib[i] = fib[i - 1] + fib[i - 2]
    return fib[n]

n = int(input())
print(fib_count(n), n - 2)
```

* `fib_count(n)` = 코드1 실행 횟수 (실제로 `fib(1)`과 `fib(2)`가 몇 번 호출되는지 = 피보나치 수 F(n))
* `n - 2` = 코드2 실행 횟수

---

### 🧠 **교훈**

* **문제에서 말하는 "실행 횟수"가 진짜 코드 실행 횟수와 항상 같은 건 아님!**
* 문제에서 **의도한 계산 과정을 그대로 구현하라는 의미일 수도 있음**
* **시간 초과를 피하는 게 중요한 문제가 아니라**, **비효율적인 재귀 구조를 일부러 사용하라고 요구**하는 문제일 수 있음

---

### 📝 기억할 것

* 재귀 피보나치는 지수 시간 → `n=30`이면 `fib(1)` 수십만 번 호출됨
* DP는 선형 시간 → `n - 2`번 연산으로 해결됨
* 피보나치 문제에서 재귀 vs DP 비교 문제일 경우, 항상 "중복 호출"을 시각화해보기!


